(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{490:function(l,v,t){"use strict";t.r(v);var _=t(59),s=Object(_.a)({},(function(){var l=this,v=l.$createElement,t=l._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[t("h2",{attrs:{id:"mysql과-oracle의-차이"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql과-oracle의-차이"}},[l._v("#")]),l._v(" MySQL과 Oracle의 차이")]),l._v(" "),t("ol",[t("li",[l._v("데이터가 저장되는 스토리지의 구조 차이")])]),l._v(" "),t("ul",[t("li",[l._v("오라클 DB는 통합된 스토리지 하나를 공유 vs MySql은 물리적인 DB서버마다 독립적인 스토리지를 할당")]),l._v(" "),t("li",[l._v("공유 스토리지를 사용하는 오라클은 사용자가 어느 DB 서버에 접속하던 같은 결과가 출력되고 동일한 CRUD 처리 가능")]),l._v(" "),t("li",[l._v("MySQL은 주로 master-slave 구조. 마스터 노드는 CRUD 수행가능, 슬레이브는 읽기만 가능. = DB 서버마다 각 역할이 나뉠 수 있다.")])]),l._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[l._v("지원하는 기능 차이")])]),l._v(" "),t("ul",[t("li",[l._v("MySQL은 조인 시 대부분 nested loop join, Oracle은 nested loop join, sort merge join(정렬 병합 조인)과 해시 조인 사용.")]),l._v(" "),t("li",[l._v("MySQL은 스토리지 엔진이라는 개념을 포함하기에 오픈소스 DBMS를 바로 꽂아 사용할 수 있는 확장성을 지님 (plug & play)")]),l._v(" "),t("li",[l._v("MySQL은 오라클 대비 낮은 메모리 사용. 저사양 PC에도 적합.")]),l._v(" "),t("li",[l._v("MySQL은 데이터가 변경되면 메모리의 캐시를 모두 삭제함으로 캐시 기능에 한계")])]),l._v(" "),t("h3",{attrs:{id:"스토리지-엔진"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#스토리지-엔진"}},[l._v("#")]),l._v(" 스토리지 엔진")]),l._v(" "),t("ul",[t("li",[l._v("sql query로 db에 저장된 디스크나 메모리에서 필요한 데이터를 가져와 MySQL 엔진으로 보냄")]),l._v(" "),t("li",[l._v("데이터 저장 방식에 따라 다름")])]),l._v(" "),t("h3",{attrs:{id:"sql-프로세스"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sql-프로세스"}},[l._v("#")]),l._v(" SQL 프로세스")]),l._v(" "),t("p",[l._v("SQL 실행 과정에서 핵핵심 오브젝트: 파서, 전처리기(preprocessor), optimizer, 엔진 실행기")]),l._v(" "),t("ul",[t("li",[l._v("파서: mysql 엔진에 속함. sql 쿼리를 최소 단위로 쪼개 문법 검사를 하며 트리로 만듦.")]),l._v(" "),t("li",[l._v("전처리기: = mysql 엔진. 파서에서 생성한 트리로 구조적 문제가 없는지 검사. (접근 권한 있는지 등)")]),l._v(" "),t("li",[l._v("옵티마이저: mysql의 핵심 엔진 중 하나. 전달된 파서 트리에서 "),t("strong",[l._v("필요없는 조건 삭제, 연산 단순화. 어떤 순서로 테이블에 접근할지, 무슨 인덱스 쓸지 등 실행 계획을 수립")]),l._v(" 단, 실행 계획 경우의 수가 너무 많으면 모든 실행계획을 계산하진 않아서 옵티마이저가 선택한 최적의 실행 계획이 무조건 best는 아닐 수도 있음")]),l._v(" "),t("li",[l._v("엔진 실행기(engine executor): Mysql 엔진과 스토리지 엔진 영역 모두에 걸침. 실행 계획을 참고해 스토리지 엔진에서 데이터를 가져옴. 이후 읽어온 데이터를 정렬하거나 조인, 불필요한 데이터는 필터링. 따라서 "),t("strong",[l._v("mysql 엔진의 부하를 줄이려면 스토리지 엔진에서 가져오는 데이터양을 줄이는게 매우 중요")])])]),l._v(" "),t("h3",{attrs:{id:"db-오브젝트들"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#db-오브젝트들"}},[l._v("#")]),l._v(" DB 오브젝트들")]),l._v(" "),t("ul",[t("li",[l._v("인덱스: DB에서 키값으로 실제 데이터 위치를 식별해 데이터 접근 속도를 높이고자 생성되는, 키 기준으로 정렬된 오브젝트")]),l._v(" "),t("li",[l._v("뷰: 가상 테이블. 뷰를 만들어 제한된 정보만 제공 가능. 여러 테이블을 join해 최적화된 뷰를 생성하면 좋음")]),l._v(" "),t("li",[l._v("쿼리 안에 중첩쿼리 있는 경우 SELECT (스칼라 섭쿼리) FROM (인라인 뷰) WHERE (중첩 섭쿼리)")]),l._v(" "),t("li",[l._v("비상관 서브쿼리: 메인, 서브쿼리가 독립적으로 실행가능한 경우. 서브쿼리 -> 메인쿼리 순서로 실행됨")]),l._v(" "),t("li",[l._v("상관 서브쿼리: 메인 -> 서브 -> 다시 메인 쿼리 순서로 실행")])]),l._v(" "),t("h3",{attrs:{id:"조인-알고리즘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#조인-알고리즘"}},[l._v("#")]),l._v(" 조인 알고리즘")]),l._v(" "),t("ul",[t("li",[l._v("driving, driven 테이블: join B on A.col = B.col인 것처럼 먼저 접근하는게 드라이빙 테이블, 그 결과로 접근하는 테이블이 드리븐 테이블. "),t("strong",[l._v("드라이빙 테이블에서 많은 건이 반환되면 그 결과를 가지고 드리븐 테이블에 접근하므로 최대한 적은 결과가 리턴될 것 같은 테이블을 드라이빙 테이블로 구성해야함")])]),l._v(" "),t("li",[l._v("nested loop join: 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 검색하는 것을 반복해 최종적으로 양쪽 테이블에 공통된 데이터를 출력")])])])}),[],!1,null,null,null);v.default=s.exports}}]);