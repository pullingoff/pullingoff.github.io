(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{548:function(t,e,r){"use strict";r.r(e);var i=r(59),a=Object(i.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"cpu-scheduling"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cpu-scheduling"}},[t._v("#")]),t._v(" CPU Scheduling")]),t._v(" "),r("ul",[r("li",[t._v("CPU를 어떤 프로세스에게 줄 지 결정")]),t._v(" "),r("li",[t._v("CPU Job이 io bound와 cpu bound 잡이 섞여있기 때문에 필요함!")]),t._v(" "),r("li",[t._v("특히 사용자와 인터랙션 하는 IO Bound Job이 cpu 필요할 때 빨리빨리 가져야 사용자가 불편하지 않음.")])]),t._v(" "),r("h2",{attrs:{id:"cpu-scheduling이-필요한-경우"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cpu-scheduling이-필요한-경우"}},[t._v("#")]),t._v(" CPU Scheduling이 필요한 경우")]),t._v(" "),r("ol",[r("li",[t._v("running -> blocked ('나 cpu 필요없어...' io 요청하는 시스템 콜)")]),t._v(" "),r("li",[t._v("running -> ready (할당된 시간 다씀. 타이머 인터럽트)")]),t._v(" "),r("li",[t._v("blocked -> ready (io 완료 후 인터럽트. 얘한테 바로 cpu 가는거 아님)")]),t._v(" "),r("li",[t._v("terminate (프로세스가 종료됐을 때)")])]),t._v(" "),r("p",[t._v("1,4는 자진 반납(nonpre-emtive) / 2,3은 preemtive(강제로 빼앗음)")]),t._v(" "),r("h2",{attrs:{id:"cpu-scheduler-독립적x-운영체제-안의-cpu-스케줄링-담당-코드"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cpu-scheduler-독립적x-운영체제-안의-cpu-스케줄링-담당-코드"}},[t._v("#")]),t._v(" CPU scheduler (독립적X, 운영체제 안의 CPU 스케줄링 담당 코드)")]),t._v(" "),r("ul",[r("li",[t._v("ready인 프로세스 중 이번에 CPU를 받을 프로세스를 고른다.")])]),t._v(" "),r("h2",{attrs:{id:"dispatcher"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dispatcher"}},[t._v("#")]),t._v(" Dispatcher")]),t._v(" "),r("ul",[r("li",[t._v("실제로 CPU를 주는 놈.")]),t._v(" "),r("li",[t._v("context switching을 하는 놈")])]),t._v(" "),r("h2",{attrs:{id:"스케줄링-성능-척도"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#스케줄링-성능-척도"}},[t._v("#")]),t._v(" 스케줄링 성능 척도")]),t._v(" "),r("h3",{attrs:{id:"시스템-입장"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#시스템-입장"}},[t._v("#")]),t._v(" 시스템 입장")]),t._v(" "),r("ol",[r("li",[t._v("CPU Utilization: CPU에 일 많이 시켜야 꿀임")])]),t._v(" "),r("ul",[r("li",[t._v("cpu를 사용한 시간 대비 일한 시간의 비율 (최대한 일 많이 해야 좋음)")])]),t._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[t._v("Throughput (처리량)")])]),t._v(" "),r("ul",[r("li",[t._v("CPU Burst의 갯수. 처리 완료한 갯수")])]),t._v(" "),r("h3",{attrs:{id:"프로세스-입장"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#프로세스-입장"}},[t._v("#")]),t._v(" 프로세스 입장")]),t._v(" "),r("ol",[r("li",[t._v("Turnaround Time (소요시간, 반환시간)")])]),t._v(" "),r("ul",[r("li",[t._v("cpu를 받아서 다 쓸 때까지 걸린 시간 (CPU burst 시작~끝)")])]),t._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[t._v("Waiting Time (대기 시간)")])]),t._v(" "),r("ul",[r("li",[t._v("프로세스가 기다린 시간")]),t._v(" "),r("li",[t._v("pre emtive의 경우 waiting 타임이 여러차례 쌓여서 길어짐")])]),t._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[t._v("Response Time (응답 시간)")])]),t._v(" "),r("ul",[r("li",[t._v("첫번째 응답이 오는데 걸린 시간 (타임 쉐어링 환경을 위한 기준)")])]),t._v(" "),r("h4",{attrs:{id:"식당-예시"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#식당-예시"}},[t._v("#")]),t._v(" 식당 예시")]),t._v(" "),r("p",[t._v("cpu utilization: 요리사가 요리한 양\nthroughput: 처리한 손님의 개수\nturnaround time: 고객이 들어와 주문하고 식사하고 나가는데 걸린 시간\nwaiting time: 코스요리에서 다음 메뉴 나오는 거 기다린 시간의 총합\nresponse time: 첫번째 음식이 나올때까지 기다린 시간")]),t._v(" "),r("h2",{attrs:{id:"cpu-스케줄링-알고리즘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cpu-스케줄링-알고리즘"}},[t._v("#")]),t._v(" CPU 스케줄링 알고리즘")]),t._v(" "),r("h3",{attrs:{id:"fcfs-선착순-first-come-first-served"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fcfs-선착순-first-come-first-served"}},[t._v("#")]),t._v(" FCFS (선착순/ First come, First Served)")]),t._v(" "),r("ul",[r("li",[t._v("별로 효율적이진 않다. CPU를 많이 쓰는 프로세스가 cpu를 가지면 CPU를 적게 쓰는 프로그램이더라도 기다려야 한다.")]),t._v(" "),r("li",[t._v("관여한 "),r("strong",[t._v("프로세스의 평균 웨이팅 타임")]),t._v("이 길어진다.")]),t._v(" "),r("li",[t._v("convoy effect: 앞에 거대한 놈이 기다리고 있어서 기다리고 있어야하는 경우를 말함.")])]),t._v(" "),r("h3",{attrs:{id:"sjf-shortest-job-first"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sjf-shortest-job-first"}},[t._v("#")]),t._v(" SJF (Shortest Job First)")]),t._v(" "),r("ul",[r("li",[t._v("프로세스를 사용하려는 시간 즉 CPU burst가 가장 짧은 놈에게 프로세스를 줌")]),t._v(" "),r("li",[t._v("preemtive: 일단 cpu 잡으면 해당 cpu burst가 완료될 때까진 cpu를 선점하지 않음")]),t._v(" "),r("li",[t._v("nonpreemtive: 현재 수행중인 프로세스의 남은 burst time보다 더 짧은 cpu burst time을 가지는 프로세스가 도착하면 cpu 빼앗아서 줌")]),t._v(" "),r("li",[t._v("nonpreemtive: "),r("strong",[t._v("shortest average waiting time")])])]),t._v(" "),r("h4",{attrs:{id:"sjf의-문제점"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sjf의-문제점"}},[t._v("#")]),t._v(" SJF의 문제점")]),t._v(" "),r("ol",[r("li",[t._v("starvation: 어떤 프로세스에겐 CPU가 계속 안 올 수도 있다.")]),t._v(" "),r("li",[t._v("예측이 쉽지 않음: 얼마나 CPU burst time이 필요한지 프로세스 자신도 모름")])]),t._v(" "),r("ul",[r("li",[t._v("Exponential averaging:")])]),t._v(" "),r("h3",{attrs:{id:"priority-scheduling-우선순위"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#priority-scheduling-우선순위"}},[t._v("#")]),t._v(" Priority scheduling (우선순위)")]),t._v(" "),r("ul",[r("li",[t._v("우선순위가 "),r("strong",[t._v("가장 높은")]),t._v(" 프로세스에게 CPU를 준다")]),t._v(" "),r("li",[t._v("preemtive는 더 우선순위가 높은 프로세스가 나타나면 cpu를 넘겨주고, nonpre는 넘겨주지 않음")]),t._v(" "),r("li",[t._v("작은 숫자가 우선순위가 높음.")]),t._v(" "),r("li",[t._v("SJF도 일종의 priority scheduling")]),t._v(" "),r("li",[t._v("Starvation의 해결법: 에이징(aging) 기법. 우선순위가 낮은 프로세스라도 오래 기다리게 되면 우선순위를 높여주자.")])]),t._v(" "),r("h2",{attrs:{id:"라운드-로빈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#라운드-로빈"}},[t._v("#")]),t._v(" 라운드 로빈")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/154834115-4b900873-d810-4c8b-bff2-173cbb397a53.png",alt:"round robin scheduling"}})]),t._v(" "),r("ul",[r("li",[t._v("**각 프로세스가 동일한 크기의 할당 시간(Time Quantum)**을 가짐.")]),t._v(" "),r("li",[t._v("Large Q: FCFS / Small Q: 매우 빈번한 Context Switch, 시스템 성능 저하 우려")]),t._v(" "),r("li",[t._v("응답 시간이 빨라짐.")]),t._v(" "),r("li",[t._v("굳이 예측할 필요 없이 CPU를 짧게 쓰는 프로세스가 짧게 쓰고 나갈 수 있음")]),t._v(" "),r("li",[r("strong",[t._v("CPU를 대기하는 시간과 쓰는 시간이 비례")])]),t._v(" "),r("li",[t._v("일반적으로 SJF보다 average turnaround time이 길지만 response time은 더 짧다.")])]),t._v(" "),r("h2",{attrs:{id:"multilevel-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#multilevel-queue"}},[t._v("#")]),t._v(" Multilevel Queue")]),t._v(" "),r("ul",[r("li",[t._v("ready queue를 우선순위별로 여러개로 분할, 모두 cpu 쓰려고 기다림")]),t._v(" "),r("li",[t._v("차별적임. 그래서 multilevel feedback queue를 도입")])]),t._v(" "),r("h3",{attrs:{id:"multilevel-feedback-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#multilevel-feedback-queue"}},[t._v("#")]),t._v(" multilevel feedback queue")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/154834381-cc5b1e4b-79d5-4a24-bbec-9f2cbfa6b1f2.png",alt:"multilevel feedback queue"}})]),t._v(" "),r("ul",[r("li",[t._v("foreground(interactive): 라운드로빈")]),t._v(" "),r("li",[t._v("background(batch, no human interaction): 선착순")]),t._v(" "),r("li",[t._v("Queue에 대한 스케줄링이 필요\n"),r("ul",[r("li",[t._v("Fixed priority scheduling: fore 부터 -> background / starvation 우려 있음")])])]),t._v(" "),r("li",[r("strong",[t._v("처음 들어온 프로세스는 우선순위 우선으로")]),t._v(" 해줬다가 여러번 필요할 수록 우선순위가 뒤로 밀린다.")])]),t._v(" "),r("h2",{attrs:{id:"multiple-processor-scheduling"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#multiple-processor-scheduling"}},[t._v("#")]),t._v(" multiple processor scheduling")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/154839986-bc4d10c5-9745-4d89-8aa7-803fd6b825da.png",alt:"다수의 프로세서 스케쥴링"}})]),t._v(" "),r("ul",[r("li",[t._v("cpu가 여러개면 스케줄링은 더 복잡해짐")]),t._v(" "),r("li",[r("strong",[t._v("load sharing")]),t._v(": 일부 프로세서에 Job이 몰리지 않게 부하를 공유")])]),t._v(" "),r("h2",{attrs:{id:"real-time-scheduling"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#real-time-scheduling"}},[t._v("#")]),t._v(" real time scheduling")]),t._v(" "),r("ul",[r("li",[t._v("real time: 정해진 데드라인 내에 끝나야함")]),t._v(" "),r("li",[t._v("미리 스케줄링을 해서 적재적소에 배치 / 주로 주기적으로 작업하는 프로세스가 많음")]),t._v(" "),r("li",[t._v("hard real time systems: 반드시 데드라인 안에 끝내야")]),t._v(" "),r("li",[t._v("soft real time systems: 일반 프로세스에 비해 높은 우선순위를 갖도록")])]),t._v(" "),r("h2",{attrs:{id:"thread-scheduling"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#thread-scheduling"}},[t._v("#")]),t._v(" Thread scheduling")]),t._v(" "),r("ul",[r("li",[t._v("Local 스케줄링: (user level thread가) 운영체제는 그냥 그 프로세스한테 cpu 줄지 안 줄지 결정. 어떤 쓰레드한테 줄지는 쓰레드 내부가 선택")]),t._v(" "),r("li",[t._v("글로벌 스케줄링: 커널 레벨 쓰레드의 경우, 커널의 단기 스케줄러가 어떤 쓰레드를 스케줄할지 결정")])]),t._v(" "),r("h2",{attrs:{id:"알고리즘-평가하는-법"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#알고리즘-평가하는-법"}},[t._v("#")]),t._v(" 알고리즘 평가하는 법")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/154840176-a16412ec-636c-4366-8531-7feb11dcfc8b.png",alt:"알고리즘 성능 평가"}})]),t._v(" "),r("ul",[r("li",[t._v("Queueing models: 도착률과 처리율(service rate) 등으로 성능을 계산")]),t._v(" "),r("li",[t._v("구현 & 성능 측정: 실제 시스템에 알고리즘을 구현해 실제 작업의 성능 측정")])])])}),[],!1,null,null,null);e.default=a.exports}}]);