(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{551:function(a,t,s){"use strict";s.r(t);var e=s(59),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"disk의-구조"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#disk의-구조"}},[a._v("#")]),a._v(" disk의 구조")]),a._v(" "),s("ul",[s("li",[a._v("로지컬 블럭: 디스크의 외부에서 보는 디스크의 최소 단위 (주소를 가진 1차원 배열처럼 취급)")]),a._v(" "),s("li",[a._v("섹터: 디스크를 내부에서 관리하는 최소 단위 (원 모양에서 잘려있는 작은 조각)\n"),s("ul",[s("li",[a._v("logical block이 물리적인 디스크에 매핑된 위치")]),a._v(" "),s("li",[a._v("sector 0은 최외곽 실린더의 첫 트랙에 있는 첫번째 섹터")])])])]),a._v(" "),s("h2",{attrs:{id:"disk-management"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#disk-management"}},[a._v("#")]),a._v(" Disk management")]),a._v(" "),s("h3",{attrs:{id:"물리-formatting-low-level-formatting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#물리-formatting-low-level-formatting"}},[a._v("#")]),a._v(" 물리 formatting (low-level formatting)")]),a._v(" "),s("ul",[s("li",[a._v("디스크를 컨트롤러가 읽고 쓸 수 있게 섹터들로 나눔")]),a._v(" "),s("li",[a._v("각 섹터는 header + 실제 데이터(보통 512바이트) + trailer로 구성됨")]),a._v(" "),s("li",[a._v("헤더와 트레일러는 sector number, ECC(Error correcting code) 등의 정보가 저장되며 controller가 직접 접근 및 운영")])]),a._v(" "),s("h3",{attrs:{id:"파티셔닝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#파티셔닝"}},[a._v("#")]),a._v(" 파티셔닝")]),a._v(" "),s("ul",[s("li",[a._v("디스크를 하나 이상의 실린더 그룹으로 나누는 과정")]),a._v(" "),s("li",[a._v("os는 이걸 독립적 disk로 취급 (logical disk)")])]),a._v(" "),s("h3",{attrs:{id:"논리-formatting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#논리-formatting"}},[a._v("#")]),a._v(" 논리 formatting")]),a._v(" "),s("ul",[s("li",[a._v("파일 시스템을 만드는 것")]),a._v(" "),s("li",[a._v("FAT, inode, free space 등의 구조 포함")])]),a._v(" "),s("h3",{attrs:{id:"부팅"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#부팅"}},[a._v("#")]),a._v(" 부팅")]),a._v(" "),s("ul",[s("li",[a._v("ROM(전원이 꺼져도 정보가 유지됨)에 있는 'small bootstrap loader'를 실행")]),a._v(" "),s("li",[a._v("sector 0 (boot block이 있는 곳)을 로드해 실행")]),a._v(" "),s("li",[a._v("sector 0은 full bootstrap loader program")]),a._v(" "),s("li",[a._v("os를 디스크에서 load해 실행 (운영체제 커널의 파일을 메모리에 올림)")])]),a._v(" "),s("h2",{attrs:{id:"disk-scheduling"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#disk-scheduling"}},[a._v("#")]),a._v(" disk scheduling")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/159148036-c372d5a1-4e93-49bb-83b9-56b666e17eb5.png",alt:"디스크 스케줄링"}})]),a._v(" "),s("ul",[s("li",[a._v("디스크 스케줄러는 논리 블럭 번호를 보고 스케줄링함.")])]),a._v(" "),s("h2",{attrs:{id:"fcfs-디스크-스케줄링-알고리즘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fcfs-디스크-스케줄링-알고리즘"}},[a._v("#")]),a._v(" FCFS 디스크 스케줄링 알고리즘")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/159148126-67014b53-b456-4cae-965d-319f3d59f4a4.png",alt:"fcfs"}})]),a._v(" "),s("ul",[s("li",[a._v("딱 봐도 헤드가 이동을 많이 하고 비효율적임")])]),a._v(" "),s("h2",{attrs:{id:"sstf-shortest-seek-time-first-헤드에서-가장-가까운-요청을-먼저-처리"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sstf-shortest-seek-time-first-헤드에서-가장-가까운-요청을-먼저-처리"}},[a._v("#")]),a._v(" SSTF(Shortest Seek Time First) : 헤드에서 가장 가까운 요청을 먼저 처리")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/159148152-ae0d187a-24b5-40a2-9afd-21037beca46a.png",alt:"sstf"}})]),a._v(" "),s("ul",[s("li",[a._v("현재 헤드에서 가까운 순서대로 요청 처리. 디스크 헤더의 이동 거리가 줄어들지만 starvation 우려가 있다.")])]),a._v(" "),s("h2",{attrs:{id:"scan에-기반한-디스크-스케줄링-엘리베이터-스케줄링-방식이라고도-함"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scan에-기반한-디스크-스케줄링-엘리베이터-스케줄링-방식이라고도-함"}},[a._v("#")]),a._v(" SCAN에 기반한 디스크 스케줄링. (엘리베이터 스케줄링 방식이라고도 함)")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/159148209-6229b149-51f2-46ac-8f0b-d31673125e01.png",alt:"scan"}})]),a._v(" "),s("ul",[s("li",[a._v("큐에 어떤 요청이 들어왔는지에 상관없이 디스크 암이 항상 한쪽 끝에서 다른쪽으로 이동하며 가는 길목에 있는 모든 요청을 처리")]),a._v(" "),s("li",[a._v("다른 한쪽에 도달하면 역방향으로 이동하며 다시 이동.")]),a._v(" "),s("li",[a._v("문제: 실린더 위치에 따라 대기 시간이 다르다. (가운데 부분은 항상 대기를 짧게 하는데, 극에 있으면 대기 시간이 길어짐)")])]),a._v(" "),s("h2",{attrs:{id:"c-scan-circular-scan"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-scan-circular-scan"}},[a._v("#")]),a._v(" C Scan (Circular Scan)")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/159148224-f807cbe2-c942-41a4-8202-c1076afd4e77.png",alt:"스크린샷 2022-03-20 오후 1 30 01"}})]),a._v(" "),s("ul",[s("li",[a._v("헤드가 한쪽->다른쪽으로 이동. 끝에 도달했으면 요청 처리 않고 곧바로 출발점으로 이동")]),a._v(" "),s("li",[a._v("SCAN보다 균일한 대기시간을 제공")])]),a._v(" "),s("h2",{attrs:{id:"n-scan"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#n-scan"}},[a._v("#")]),a._v(" N Scan")]),a._v(" "),s("ul",[s("li",[a._v("출발하면서 기존에 큐에 있던 요청들은 처리하되, 중간에 들어온 요청은 건너뜀. 그리고 돌아갈때 지난번에 들어온 요청들만 처리함")])]),a._v(" "),s("h2",{attrs:{id:"look-c-look"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#look-c-look"}},[a._v("#")]),a._v(" Look & C Look")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/159148289-64d182aa-7f29-47c1-b2e9-6d91e269f42e.png",alt:"스크린샷 2022-03-20 오후 1 32 19"}})]),a._v(" "),s("ul",[s("li",[a._v("요청이 없어도 끝까지 가고 보는 Scan, C scan의 단점을 개선.")]),a._v(" "),s("li",[a._v("한쪽 방향으로 가다가 요청이 더 없으면 방향을 바꿈")]),a._v(" "),s("li",[a._v("위 사진의 경우 183 이상의 요청이 없으니 199까지 안 가고 유턴함")])]),a._v(" "),s("h2",{attrs:{id:"디스크-스케줄링-알고리즘-결정"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#디스크-스케줄링-알고리즘-결정"}},[a._v("#")]),a._v(" 디스크 스케줄링 알고리즘 결정")]),a._v(" "),s("ul",[s("li",[a._v("디스크 스케줄링 알고리즘은 주로 SCAN에 기반한 알고리즘들을 사용함. 룩, 씨룩이 일반적으로 디스크 IO가 많은 시스템에서 효율적")]),a._v(" "),s("li",[a._v("파일 할당 방법에 따라 디스크 요청이 영향을 받음")]),a._v(" "),s("li",[a._v("디스크 스케줄링 알고리즘은 필요할 경우 다른 알고리즘으로 쉽게 교체할 수 있도록 os와 별도의 모듈로 작성되는 것이 바람직")])]),a._v(" "),s("h2",{attrs:{id:"swap-space-management"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#swap-space-management"}},[a._v("#")]),a._v(" Swap-Space Management")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://user-images.githubusercontent.com/50111853/159148421-51e543d6-8155-40d1-abcf-156941ffb872.png",alt:"swap space"}})]),a._v(" "),s("ul",[s("li",[a._v("프로그램 실행을 위한 메모리의 연장공간으로 Swap area로서 디스크를 사용")]),a._v(" "),s("li",[a._v("물리적 디스크를 파티셔닝해 로지컬 디스크를 만들수있다. 그럼 운영체제는 각각의 디스크로 간주하고, 파일시스템을 깔거나 swap area로 사용가능.")]),a._v(" "),s("li",[a._v("swap in out할때 빠르게 해야하는데 디스크 접근 시간의 대부분은 seek time이라 이걸 줄이는게 중요. 스왑 에리아는 공간 효율성보다 속도 효율성이 중요 (공간은 어차피 프로세스 사라지면 다 지워짐)")]),a._v(" "),s("li",[a._v("seek time을 줄이기 위해 큰 단위를 순차적으로 할당 (file system은 512 bytes, swap area는 512 kilobytes)")])]),a._v(" "),s("h2",{attrs:{id:"raid-redundant-array-of-independent-disks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#raid-redundant-array-of-independent-disks"}},[a._v("#")]),a._v(" RAID (Redundant Array of Independent Disks)")]),a._v(" "),s("ul",[s("li",[a._v("저렴한 여러 디스크를 묶어서 사용함. 레이드 방식은 여러개다. (중복 저장 또는 분산 저장)")])]),a._v(" "),s("h3",{attrs:{id:"사용-목적"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#사용-목적"}},[a._v("#")]),a._v(" 사용 목적")]),a._v(" "),s("ul",[s("li",[a._v("디스크 처리 속도 향상 :여러 디스크에 내용을 분산 저장해 병렬적으로 읽어옴 (interleaving, striping)")]),a._v(" "),s("li",[a._v("신뢰성 향상: 동일 정보를 여러 디스크에 중복 저장. 하나의 디스크가 고장 시 다른 디스크에서 읽어옴 (mirroring, shadowing)")]),a._v(" "),s("li",[a._v("단순한 중복 저장이 아니라 일부 디스크에 parity를 저장해 공간의 효율성을 높일 수 있음")])])])}),[],!1,null,null,null);t.default=r.exports}}]);