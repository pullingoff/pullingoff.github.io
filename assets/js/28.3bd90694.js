(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{484:function(t,a,v){"use strict";v.r(a);var _=v(59),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"복잡도"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#복잡도"}},[t._v("#")]),t._v(" 복잡도")]),t._v(" "),v("h3",{attrs:{id:"시간-복잡도"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#시간-복잡도"}},[t._v("#")]),t._v(" 시간 복잡도")]),t._v(" "),v("ul",[v("li",[t._v("얼마나 오래 걸리는지, 연산 횟수")]),t._v(" "),v("li",[t._v("2중 반복문이라고 항상 시간 복잡도가 "),v("code",[t._v("O(N^2)")]),t._v("는 아님. 코드가 내부적으로 다른 함수를 호출하면 내부 함수의 시간복잡도도 고려해야함")]),t._v(" "),v("li",[t._v("퀵 정렬의 평균 시간 복잡도는 "),v("code",[t._v("O(NlogN)")]),t._v("이지만 최악의 경우 "),v("code",[t._v("O(N^2)")]),t._v("임. 일반적으로 코테에서는 최악의 경우의 연산횟수(시간복잡도)를 우선 고려해야함")]),t._v(" "),v("li",[t._v("일반적으로 O(N^3)을 넘어가지 않아야함")])]),t._v(" "),v("h4",{attrs:{id:"big-o-표기법"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#big-o-표기법"}},[t._v("#")]),t._v(" Big-O 표기법")]),t._v(" "),v("ul",[v("li",[t._v("가장 빠르게 증가하는 항(최고차항)만 고려함")]),t._v(" "),v("li",[t._v("하지만 연산횟수가 "),v("code",[t._v("3N^3+5N^2+1000000")]),t._v("인 알고리즘이 있다면, 실제로 N이 작을땐 상수값이 미치는 영향이 크다. 빅오표기법이 절대적인 것은 아님")])]),t._v(" "),v("h3",{attrs:{id:"시간-제한이-1초일-때-풀수-있는-알고리즘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#시간-제한이-1초일-때-풀수-있는-알고리즘"}},[t._v("#")]),t._v(" 시간 제한이 1초일 때 풀수 있는 알고리즘")]),t._v(" "),v("p",[t._v("데이터의 개수(N)의 범위가 500: 시간 복잡도가 O(N^3)\n데이터의 개수(N)의 범위가 2000: 시간 복잡도가 O(N^2)\n데이터의 개수(N)의 범위가 10만: 시간 복잡도가 O(NlogN)\n데이터의 개수(N)의 범위가 천만: 시간 복잡도가 O(N)")]),t._v(" "),v("h3",{attrs:{id:"공간-복잡도"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#공간-복잡도"}},[t._v("#")]),t._v(" 공간 복잡도")]),t._v(" "),v("ul",[v("li",[t._v("사용하는 메모리의 양")])]),t._v(" "),v("p",[t._v("이 둘은 자주 tradeoff")])])}),[],!1,null,null,null);a.default=r.exports}}]);