(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{420:function(a,t,i){a.exports=i.p+"assets/img/osmm1.3942296e.png"},421:function(a,t,i){a.exports=i.p+"assets/img/osmm2.5f0b8516.png"},422:function(a,t,i){a.exports=i.p+"assets/img/osmm3.8b52ba10.png"},423:function(a,t,i){a.exports=i.p+"assets/img/osmm4.58a3de2e.png"},424:function(a,t,i){a.exports=i.p+"assets/img/osmm5.74a53a3a.png"},547:function(a,t,i){"use strict";i.r(t);var s=i(59),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("메모리 참조를 하기 위해선 CPU가 논리 메모리 주소를 주면 물리 메모리 주소로 바꿔야한다. 하드웨어가 해줘야하는 역할들과 메모리 주소 바인딩 방법에 대해 배운다.")]),a._v(" "),s("h2",{attrs:{id:"논리-주소-vs-물리-주소"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#논리-주소-vs-물리-주소"}},[a._v("#")]),a._v(" 논리 주소 vs. 물리 주소")]),a._v(" "),s("h3",{attrs:{id:"논리-주소-virtual-address"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#논리-주소-virtual-address"}},[a._v("#")]),a._v(" 논리 주소 (=virtual address)")]),a._v(" "),s("ul",[s("li",[a._v("프로그램이 실행되면 생기는 독자적인 주소 공간")]),a._v(" "),s("li",[a._v("각 프로세스마다 0번지부터 시작")]),a._v(" "),s("li",[s("strong",[a._v("CPU가 보는 주소")])])]),a._v(" "),s("h3",{attrs:{id:"물리-주소"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#물리-주소"}},[a._v("#")]),a._v(" 물리 주소")]),a._v(" "),s("ul",[s("li",[a._v("메모리에 실제 올라가는 위치")])]),a._v(" "),s("h3",{attrs:{id:"주소-바인딩-주소를-결정하는것"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#주소-바인딩-주소를-결정하는것"}},[a._v("#")]),a._v(" 주소 바인딩: 주소를 결정하는것")]),a._v(" "),s("p",[a._v("symbolic -(컴파일)-> logical -(실행을 위해 주소 변환)-> physical address\n프로그래머 입장에선 숫자가 아닌 symbolic addr 사용.")]),a._v(" "),s("p",[s("img",{attrs:{src:i(420),alt:"주소 바인딩 예시"}})]),a._v(" "),s("ul",[s("li",[a._v("소스코드: 심볼릭 주소(A,B)가 쓰임. A,B를 더한 후 C로 점프하라")]),a._v(" "),s("li",[a._v("실행파일: 심볼릭 주소가 논리 주소(20,30)로 바뀜. 각각의 문장이 메모리 0번지~40번지에 들어감.")]),a._v(" "),s("li",[a._v("실행시작: 물리적 메모리에 올라간다(= 주소 바인딩 된다.)")])]),a._v(" "),s("h2",{attrs:{id:"주소-바인딩의-시점"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#주소-바인딩의-시점"}},[a._v("#")]),a._v(" 주소 바인딩의 시점")]),a._v(" "),s("h3",{attrs:{id:"compile-time-바인딩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compile-time-바인딩"}},[a._v("#")]),a._v(" compile time 바인딩")]),a._v(" "),s("ul",[s("li",[a._v("컴파일 시점에 이미 물리적 메모리 주소가 결정됨 => 컴파일러가 절대 코드(absolute code) 생성")]),a._v(" "),s("li",[a._v("메모리 주소 시작 위치 변경시 재컴파일 해야함")]),a._v(" "),s("li",[a._v("실행파일에 있는 Add '20,30'이 논리 주소가 그대로 사용됨. -> "),s("strong",[a._v("비효율적")])]),a._v(" "),s("li",[a._v("컴퓨터 안에서 프로그램이 1개만 실행될 때 그나마 나음")])]),a._v(" "),s("h3",{attrs:{id:"실행시간-load-time-바인딩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#실행시간-load-time-바인딩"}},[a._v("#")]),a._v(" 실행시간(Load time) 바인딩")]),a._v(" "),s("ul",[s("li",[a._v("프로그램이 실행 시작되면 물리적 메모리 주소 결정됨")]),a._v(" "),s("li",[a._v("로더의 책임 하에 물리적 메모리 주소 부여")]),a._v(" "),s("li",[a._v("컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능 /빈 위치에는 실행 시 어디든 올라갈 수 있음")])]),a._v(" "),s("h3",{attrs:{id:"런타임-바인딩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#런타임-바인딩"}},[a._v("#")]),a._v(" 런타임 바인딩")]),a._v(" "),s("ul",[s("li",[a._v("실행시에 프로세스 메모리 주소가 결정되는건 로드타임 바인딩과 같으나 "),s("strong",[a._v("프로그램 실행중에도 주소가 바뀔 수 있음")]),a._v(" (메모리에서 쫓겨난다거나)")]),a._v(" "),s("li",[a._v("CPU가 주소를 참조할 때마다 바인딩이 어디 됐는지 체크해봐야한다. (address mapping table)")]),a._v(" "),s("li",[a._v("주소 참조시마다 바인딩 위치 확인하려면 하드웨어의 지원이 필요함 (base and limit registers, MMU)")]),a._v(" "),s("li",[a._v("MMU가 주소 변환을 그때그때 해준다.")])]),a._v(" "),s("h4",{attrs:{id:"cpu는-물리-주소를-바라볼까"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpu는-물리-주소를-바라볼까"}},[a._v("#")]),a._v(" CPU는 물리 주소를 바라볼까?")]),a._v(" "),s("p",[a._v("CPU가 하드웨어라 물리 주소를 바라볼 것 같지만 바라보는 주소는 논리 주소다.\n프로그램이 실행돼 메모리에 올라가도 명령어 코드에 있는 주소는 논리 주소다 (load time binding)\n메모리에 올라갈때 시작 위치(500~)는 바뀌지만 그 안의 주소는 논리주소로 남아있기 때문임.")]),a._v(" "),s("h3",{attrs:{id:"mmu-memory-management-unit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mmu-memory-management-unit"}},[a._v("#")]),a._v(" MMU (Memory Management Unit)")]),a._v(" "),s("ul",[s("li",[a._v("논리 주소를 물리 주소로 매핑해주는 하드웨어")]),a._v(" "),s("li",[a._v("2개의 레지스터 사용 (base(relocation) register + limit register)")]),a._v(" "),s("li",[a._v("방법: 사용자 프로세스가 CPU에서 수행되며 생성하는 모든 주소값에 base register의 값을 더한다.")])]),a._v(" "),s("h4",{attrs:{id:"mmu-동작-원리-dynamic-relocation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mmu-동작-원리-dynamic-relocation"}},[a._v("#")]),a._v(" MMU 동작 원리 (Dynamic Relocation)")]),a._v(" "),s("p",[s("img",{attrs:{src:i(421),alt:"dynamic relocation"}})]),a._v(" "),s("ul",[s("li",[a._v("프로세스 P1은 논리주소: 0~3000번지 / 물리주소: 14000번지~")]),a._v(" "),s("li",[a._v("CPU 왈: 0번지~ 346번지 주셈")])]),a._v(" "),s("p",[a._v("=> 프로그램의 논리주소(346)+시작위치(14000) = 물리주소(14346)")]),a._v(" "),s("h4",{attrs:{id:"리밋-limit-레지스터"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#리밋-limit-레지스터"}},[a._v("#")]),a._v(" 리밋(Limit) 레지스터")]),a._v(" "),s("ul",[s("li",[a._v("논리 주소 범위(끝)를 기억한다.")]),a._v(" "),s("li",[a._v("만약 악의적인 프로그램이 "),s("strong",[a._v("실제 자기가 있지 않은 논리 주소를 달라고 하면?")]),a._v(" 물리주소가 달라진다. => 다른 프로그램의 피지컬 메모리 주소 주는 걸 방지하기 위해 리밋 레지스터를 사용")])]),a._v(" "),s("h5",{attrs:{id:"cpu가-논리-주소로-요청-논리-주소가-리밋-레지스터의-범위-내에-있는지-확인-리밋-레지스터-범위를-벗어나면-트랩-소프트웨어-인터럽트-발생시킴-악의적-접근이-아니었으면-relocation-base-register로-주소-변환"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpu가-논리-주소로-요청-논리-주소가-리밋-레지스터의-범위-내에-있는지-확인-리밋-레지스터-범위를-벗어나면-트랩-소프트웨어-인터럽트-발생시킴-악의적-접근이-아니었으면-relocation-base-register로-주소-변환"}},[a._v("#")]),a._v(" CPU가 논리 주소로 요청 -> 논리 주소가 리밋 레지스터의 범위 내에 있는지 확인 -> 리밋 레지스터 범위를 벗어나면 트랩(소프트웨어 인터럽트) 발생시킴 -> 악의적 접근이 아니었으면 relocation(base) register로 주소 변환")]),a._v(" "),s("p",[a._v("=> 그 결과 프로그램은 논리 주소만 다르고, 실제 물리 주소는 알 필요가 없음.")]),a._v(" "),s("h2",{attrs:{id:"dynamic-loading-동적-로딩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-loading-동적-로딩"}},[a._v("#")]),a._v(" Dynamic Loading (동적 로딩)")]),a._v(" "),s("ul",[s("li",[a._v("프로세스 전체를 메모리에 미리 다 올리는 게 아니라 해당 "),s("strong",[a._v("루틴이 호출되면 메모리에 로드")])]),a._v(" "),s("li",[a._v("메모리를 효율적으로 사용 가능")]),a._v(" "),s("li",[a._v("가끔씩 쓰는 많은 양의 코드를 쓸 때 유용 (e.g. 오류 처리 루틴)")]),a._v(" "),s("li",[a._v("운영체제가 지원하는게 아니라 라이브러리를 지원해주면 프로그래머가 프로그램 내에 구현")])]),a._v(" "),s("h2",{attrs:{id:"overlays-매뉴얼-오버레이"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#overlays-매뉴얼-오버레이"}},[a._v("#")]),a._v(" Overlays (매뉴얼 오버레이)")]),a._v(" "),s("ul",[s("li",[a._v("프로세스의 실제 필요한 정보만 메모리에 올림")]),a._v(" "),s("li",[a._v("프로세스의 크기가 메모리보다 클 때 유용")]),a._v(" "),s("li",[a._v("프로그래머가 직접 메모리에 올렸다 내렸다~ 구현하는거고 프로그래밍이 매우 복잡")])]),a._v(" "),s("h2",{attrs:{id:"스와핑"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#스와핑"}},[a._v("#")]),a._v(" 스와핑")]),a._v(" "),s("ul",[s("li",[a._v("프로세스를 일시적으로 backing store로 내쫓는 것")]),a._v(" "),s("li",[a._v("중기 스케줄러 (스와퍼)가 우선순위 낮은 프로세스를 골라서 swap out")]),a._v(" "),s("li",[a._v("swap out: backing store(swap area)로 내쫓음")]),a._v(" "),s("li",[a._v("swap in: backing store(swap area)에서 다시 불러들임")]),a._v(" "),s("li",[a._v("컴파일/ 로드 타임 바인딩이면 돌아올 떄 메모리 원래 위치로 돌아와야하기 때문에 별로 쓸데 없음.")]),a._v(" "),s("li",[s("strong",[a._v("런타임 바인딩할 때 써서 추후 빈 메모리 영역 아무데나로 가져오는게 가장 효율적임")])]),a._v(" "),s("li",[a._v("메모리에서 상당히 방대한 양을 내쫓거나/ 가져오는 거기 때문에 디스크 접근하는 시간의 대부분이 데이터 전송 시간(transfer time)이다. swap 되는 양에 비례함.")])]),a._v(" "),s("h2",{attrs:{id:"linking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linking"}},[a._v("#")]),a._v(" Linking")]),a._v(" "),s("ul",[s("li",[a._v("프로그램을 작성하고 컴파일한 후 그 컴파일 된 파일들을 모아 실행파일로 만드는 것")])]),a._v(" "),s("h3",{attrs:{id:"static-linking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#static-linking"}},[a._v("#")]),a._v(" Static Linking")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("라이브러리가 프로그램의 실행 파일 코드에 포함됨")]),a._v(" -> 실행 파일의 크기가 커짐")]),a._v(" "),s("li",[a._v("동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비 (e.g. printf 함수의 라이브러리 코드)")])]),a._v(" "),s("h3",{attrs:{id:"dynamic-linking-동적-연결"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-linking-동적-연결"}},[a._v("#")]),a._v(" Dynamic Linking (동적 연결)")]),a._v(" "),s("ul",[s("li",[a._v("라이브러리가 실행파일 코드에 들어가지 않고 "),s("strong",[a._v("실행 시에 동적 연결됨")])]),a._v(" "),s("li",[a._v("라이브러리 호출 부분에 "),s("strong",[a._v("라이브러리 루틴의 위치를 찾는 stub")]),a._v("이라는 작은 코드를 둔다.")]),a._v(" "),s("li",[a._v("라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면 디스크에서 읽어온다")]),a._v(" "),s("li",[a._v("운영체제의 도움이 필요")])]),a._v(" "),s("h2",{attrs:{id:"물리적-메모리"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#물리적-메모리"}},[a._v("#")]),a._v(" 물리적 메모리")]),a._v(" "),s("p",[s("img",{attrs:{src:i(422),alt:"allocation of physical memory"}})]),a._v(" "),s("ul",[s("li",[a._v("연속 할당: 프로세스 하나가 메모리의 연속적인 공간에 적재됨")]),a._v(" "),s("li",[a._v("불연속 할당: 프로세스 하나를 나눠서 메모리의 여러 영역에 분산해 올림")])]),a._v(" "),s("h2",{attrs:{id:"연속-할당"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#연속-할당"}},[a._v("#")]),a._v(" 연속 할당")]),a._v(" "),s("p",[s("img",{attrs:{src:i(423),alt:"메모리 연속 할당"}})]),a._v(" "),s("h3",{attrs:{id:"고정-분할-방식"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#고정-분할-방식"}},[a._v("#")]),a._v(" 고정 분할 방식")]),a._v(" "),s("ul",[s("li",[a._v("프로그램이 들어갈 물리적 메모리 영역을 미리 영구적으로 나눠놓음 (partition)")]),a._v(" "),s("li",[a._v("융통성이 없음. 최대 수행 가능한 프로그램의 크기가 제한되어있음.")]),a._v(" "),s("li",[a._v("fragmentation(조각) 발생: 프로그램B가 분할3에 들어갔지만 남음. 프로그램B에게 할당됐지만 사용 안되는 부분 등")])]),a._v(" "),s("h3",{attrs:{id:"가변-분할-방식"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#가변-분할-방식"}},[a._v("#")]),a._v(" 가변 분할 방식")]),a._v(" "),s("ul",[s("li",[a._v("분할의 크기, 갯수가 동적으로 변함")]),a._v(" "),s("li",[a._v("B가 끝나고 D가 수행되는데 B가 들어갔던 부분은 D에게는 작아서 B가 끝나도 다른 자리로 들어감")])]),a._v(" "),s("h4",{attrs:{id:"hole"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hole"}},[a._v("#")]),a._v(" Hole")]),a._v(" "),s("p",[s("img",{attrs:{src:i(424),alt:""}})]),a._v(" "),s("ul",[s("li",[a._v("사진 속 노란 공간이 hole (가용 공간)")]),a._v(" "),s("li",[a._v("프로세스가 도착하면 hole에 넣는다.")])]),a._v(" "),s("h4",{attrs:{id:"동적-저장공간-할당-dynamic-storage-allocation-문제-알고리즘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#동적-저장공간-할당-dynamic-storage-allocation-문제-알고리즘"}},[a._v("#")]),a._v(" 동적 저장공간 할당(dynamic storage allocation) 문제 (알고리즘)")]),a._v(" "),s("p",[a._v(": 가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole 을 찾는 문제")]),a._v(" "),s("ol",[s("li",[a._v("First-fit: size가 n 이상인 것 중 맨 처음으로 찾은 hole에 할당")]),a._v(" "),s("li",[a._v("Best-fit: size가 n 이상인 가장 작은 hole을 찾아서 할당 / 홀의 리스트가 크기순 정렬아닌 경우 모든 hole을 탐색하는데 시간 소요")]),a._v(" "),s("li",[a._v("Worst-fit: 가장 큰 hole에 할당. 역시 모든 리스트를 탐색해야함. 상대적으로 아주 큰 hole들이 생성됨.")])]),a._v(" "),s("p",[a._v("=> First-fit, best-fit이 worst-fit보다 속도/공간 이용률 측면에서 효과적임")]),a._v(" "),s("h4",{attrs:{id:"compaction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compaction"}},[a._v("#")]),a._v(" Compaction")]),a._v(" "),s("ul",[s("li",[a._v("외부조각으로 생기는 hole을 한군데로 몰아 아주 큰 hole로 모아 큰 block으로 만듦")]),a._v(" "),s("li",[a._v("매우 비용이 많이 드는 방법임")]),a._v(" "),s("li",[a._v("런타임 바인딩이 지원되어야 가능함.")])])])}),[],!1,null,null,null);t.default=v.exports}}]);