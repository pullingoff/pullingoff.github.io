(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{432:function(t,a,s){t.exports=s.p+"assets/img/osmm6.bd02b440.png"},433:function(t,a,s){t.exports=s.p+"assets/img/osmm8.80eb0dd7.png"},434:function(t,a,s){t.exports=s.p+"assets/img/osmm10.4da0f62e.png"},435:function(t,a,s){t.exports=s.p+"assets/img/osmm11.3f765f05.png"},436:function(t,a,s){t.exports=s.p+"assets/img/osmm7.b10deb9e.png"},550:function(t,a,s){"use strict";s.r(a);var r=s(59),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("지난번에 사용자 프로세스를 메모리에 연속적으로 올리는 방법을 배웠다."),r("br"),t._v("\n프로그램을 연속적으로 메모리에 할당하게 되면 시작 논리 메모리 주소만 알면 실제 물리 메모리의 주소로 변환하기 아주 쉬웠다."),r("br"),t._v("\n이번엔 메모리를 나눠 피지컬 메모리에 불연속으로 할당하는 기법을 배워본다.")]),t._v(" "),r("h2",{attrs:{id:"불연속-할당"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#불연속-할당"}},[t._v("#")]),t._v(" 불연속 할당")]),t._v(" "),r("h3",{attrs:{id:"segmentation-프로그램을-의미있는-단위별로-자름"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#segmentation-프로그램을-의미있는-단위별로-자름"}},[t._v("#")]),t._v(" segmentation: 프로그램을 의미있는 단위별로 자름")]),t._v(" "),r("ul",[r("li",[t._v("코드/데이터/스택 세그먼트로 나누거나 더 잘게 자를 수도 있음.")]),t._v(" "),r("li",[t._v("크기가 균일하지 않아 dynamic storage allocation problem 문제 일어남")])]),t._v(" "),r("h3",{attrs:{id:"페이징-프로세스의-virtual-memory를-같은-크기로-잘라-페이지-단위로-나눔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#페이징-프로세스의-virtual-memory를-같은-크기로-잘라-페이지-단위로-나눔"}},[t._v("#")]),t._v(" 페이징: 프로세스의 virtual memory를 같은 크기로 잘라 페이지 단위로 나눔")]),t._v(" "),r("p",[r("img",{attrs:{src:s(432),alt:"페이징 기법 설명"}})]),t._v(" "),r("ul",[r("li",[t._v("가상 메모리의 내용이 페이지 단위로 "),r("strong",[t._v("불연속적")]),t._v(" 으로 저장됨")]),t._v(" "),r("li",[t._v("hole의 크기가 균일하지 않은 것을 걱정할 필요 없음")]),t._v(" "),r("li",[t._v("주소 바인딩(변환)을 페이지별로 해야함/ 일부는 backing storage에, 일부는 피지컬 메모리에 저장.")])]),t._v(" "),r("h3",{attrs:{id:"페이징-테이블"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#페이징-테이블"}},[t._v("#")]),t._v(" 페이징 테이블")]),t._v(" "),r("p",[r("img",{attrs:{src:s(433),alt:"페이징 예시"}})]),t._v(" "),r("ul",[r("li",[t._v("각각의 프로세스별로 존재하며/ 논리 메모리가 물리적 메모리의 어느 부분에 들어가 있는가를 매핑해둔 테이블")]),t._v(" "),r("li",[t._v("3번 페이지는 7번 프레임에 들어가있다. (페이징 프레임: 페이지가 들어가있는 공간)")]),t._v(" "),r("li",[t._v("페이지 테이블은 메인 메모리에 상주.")])]),t._v(" "),r("p",[r("img",{attrs:{src:s(434),alt:"페이징 예시"}})]),t._v(" "),r("ul",[r("li",[t._v("Page-table base register (PTBR)가 페이지 테이블을 가리킴")]),t._v(" "),r("li",[t._v("Page-table limit register (PTLR)가 테이블 크기를 보관")]),t._v(" "),r("li",[t._v("모든 메모리 접근 연산에는 2번의 메모리 액세스가 필요 (페이지 테이블 접근 1번, 실제 데이터/명령어 접근 1번)")]),t._v(" "),r("li",[t._v("속도 향상을 위해 associative register(TLB) 사용")])]),t._v(" "),r("h4",{attrs:{id:"tlb-translation-look-aside-buffer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tlb-translation-look-aside-buffer"}},[t._v("#")]),t._v(" TLB (Translation Look-aside Buffer)")]),t._v(" "),r("ul",[r("li",[t._v("주소 변환을 위한 "),r("strong",[t._v("캐시")]),t._v(" 메모리. 고속의 lookup hardware cache!")]),t._v(" "),r("li",[t._v("페이징 테이블의 일부 (자주 조회되는 주소)를 저장")]),t._v(" "),r("li",[t._v("병렬 검색. tlb에 없으면 TLB Miss 라고 함.")]),t._v(" "),r("li",[t._v("TLB의 전체를 검색해봐도 없으면 메인 메모리에 있는 page table에서 프레임 번호를 얻음.")]),t._v(" "),r("li",[t._v("TLB는 컨텍스트 스위칭 때 flush")])]),t._v(" "),r("h2",{attrs:{id:"_2단계-페이지-테이블"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2단계-페이지-테이블"}},[t._v("#")]),t._v(" 2단계 페이지 테이블")]),t._v(" "),r("p",[r("img",{attrs:{src:s(435),alt:"2단계 페이징"}})]),t._v(" "),r("h3",{attrs:{id:"왜-필요한가"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#왜-필요한가"}},[t._v("#")]),t._v(" 왜 필요한가?")]),t._v(" "),r("ul",[r("li",[t._v("현대의 컴퓨터는 주소 공간이 매우 넓은 프로그램을 지원한다. 그러나 대부분의 프로그램이 그 주소공간 중 일부만 사용하므로 페이지 테이블 공간이 심하게 낭비된다.")])]),t._v(" "),r("h3",{attrs:{id:"해결-방법"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#해결-방법"}},[t._v("#")]),t._v(" 해결 방법")]),t._v(" "),r("ul",[r("li",[t._v("페이지 테이블 자체를 페이지로 구성 (다단계 페이징 기법)")]),t._v(" "),r("li",[t._v("사용하지 않는 주소 공간에 대한 외부 페이지 테이블은 NULL로 설정해 대응하는 내부 페이지 테이블을 생성X")]),t._v(" "),r("li",[t._v("페이지 테이블을 두단계 거침. 속도가 빨라지진 않지만 페이지 테이블을 위한 공간이 줄어듦")]),t._v(" "),r("li",[t._v("메모리 공간은 결국 적게 쓰지만 페이지 테이블의 수가 증가하므로 시간이 소요됨 (tradeoff)")])]),t._v(" "),r("p",[r("img",{attrs:{src:s(436),alt:"2단계 페이징"}})]),t._v(" "),r("ul",[r("li",[t._v("논리 주소: P1(외부 페이지 테이블 인덱스) + P2(내부 페이지 테이블 인덱스) + d(페이지 오프셋)")]),t._v(" "),r("li",[t._v("최종 물리 메모리 주소: 외부 페이지 tb에서 P1만큼 떨어진 주소에서 내부 페이지 테이블 주소 얻고 여기서 P2만큼 떨어진 위치에서 페이지 프레임 위치를 얻은 후 해당 프레임에서 d만큼 떨어진 곳")])])])}),[],!1,null,null,null);a.default=e.exports}}]);